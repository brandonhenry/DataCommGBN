// client.cpp
// authors: Antonio Barnes (adb680) and Jeremy Brown (jdb587)

#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fstream>
#include "packet.cpp"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
using namespace std;

// This is the maximum size of the window that it can hold.
#define WINDOW_SIZE 7
// Sequence numbers.
#define SEQUENCENUM 8


int main (int argc, char *argv[]){
    // Sent packet chunks
	int numSent = 0;
    // ACKS received
	int numReceived = 0;
    // descriptors
	int sending, receiving;
    // Max is 8
	int base = 0;
    // Next sequence number
	int nextSequenceNum;
    // store chunks
	int loop1 = 0;
	int myinitial = 0;
	char fileBuffer[1024][31];
    // store serialized packet value
	char sendData[37];
    // store deserialized packet value
  char receiveData[12];
    // receiver buffer
	char receiverBuffer[1024];
    // chunk buffer
	char chunkBuffer[30];
    // Send to and receive from emulator
	struct sockaddr_in emulatorSent, emulatorReceived;
    // Convert the send address
	struct hostent *sendAddress = gethostbyname(argv[1]);
    // Convert the receive address
  struct hostent *receiveAddress = gethostbyname("localhost");
    // deals with timeot
	struct timeval timeout;
    // size variables for the size of sent and received emulator info
	socklen_t size1, size2;
	// Timeout of 2s
	timeout.tv_sec = 0;
	timeout.tv_usec = 2000000;

    // Intialize packet
	packet *packetReceived = new packet(-1, -1, -1, receiveData);

	// Create sending and receiving sockets
	sending = socket(AF_INET, SOCK_DGRAM, 0);
	receiving = socket(AF_INET, SOCK_DGRAM, 0);

    // sending side of client
	emulatorSent.sin_family = AF_INET;
  emulatorSent.sin_port = htons(atoi(argv[2]));
	memcpy(&emulatorSent.sin_addr, sendAddress->h_addr_list[0], sendAddress->h_length);

	// receiving side of client
	emulatorReceived.sin_family = AF_INET;
  emulatorReceived.sin_port = htons(atoi(argv[3]));
	memcpy(&emulatorReceived.sin_addr, receiveAddress->h_addr_list[0], receiveAddress->h_length);
	bind(receiving,(struct sockaddr *) &emulatorReceived, sizeof(emulatorReceived));
	setsockopt(receiving, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    // size variables for the size of sent and received emulator info
  size1 = sizeof(emulatorSent);
	size2 = sizeof(emulatorReceived);

    // Open file
	ifstream in_file(argv[4], ifstream::binary);
    // 2 output files generated by client
	ofstream seqnum_file("seqnum.log"), ack_file("ack.log");

	while(1){

		// Sending phase
        int fullSize = base + WINDOW_SIZE;
		    while ((numSent < (base + WINDOW_SIZE)) && (in_file.read(chunkBuffer, sizeof(chunkBuffer)).gcount() >= 1)){
            // see if anything is left to be read
            // buffer to 0
			       bzero(sendData, sizeof(sendData));
			       nextSequenceNum = numSent % SEQUENCENUM;
            // Copy chunkBuffer into fileBuffer
			       strcpy(fileBuffer[numSent], chunkBuffer);
            // Initialize new packet
			       packet *packetSent = new packet(1, nextSequenceNum, strlen(fileBuffer[numSent]), fileBuffer[numSent]);
            // Serialize packet
			       packetSent->serialize(sendData);
			       delete packetSent;
            // Send serialized packet
			       sendto(sending, sendData, strlen(sendData), 0, (struct sockaddr *) &emulatorSent, size1);
			       printf("type: %d %s\n", nextSequenceNum, sendData);
            // the next sequence number is written to the seqnum.log file
			       seqnum_file << nextSequenceNum << endl;
			       numSent += 1;
            // buffer to zero
			       bzero(chunkBuffer, sizeof(chunkBuffer)); // Clear chunk buffer
		     }

		// Listening phase
        // buffer to 0
		    bzero(receiverBuffer, sizeof(receiverBuffer));
        // buffer to 0
		    bzero(receiveData, sizeof(receiveData));
        // Timeout
		    if ((recvfrom(receiving, receiverBuffer, sizeof(receiverBuffer), 0, (struct sockaddr *) &emulatorReceived, &size2) == -1) && (errno == 11)){
            int bottom = base - 1;
			      for (int n = bottom; n <numSent; ++n){ // Resend
				         if(loop1 == myinitial){
				               nextSequenceNum = n % SEQUENCENUM;
				               bzero(sendData, sizeof(sendData));
				               packet *packetSent = new packet(1, nextSequenceNum, strlen(fileBuffer[n]), fileBuffer[n]);
				               packetSent->serialize(sendData);
				               delete packetSent;
				               printf("Resent packet %d: %s\n", nextSequenceNum, sendData);
				               sendto(sending, sendData, strlen(sendData), 0, (struct sockaddr *) &emulatorSent, size1);
				               seqnum_file << nextSequenceNum << endl;
				         }
			       }
			   continue;
		  }

        // No Timeout
		else{
            // Deserialize data
			packetReceived->deserialize(receiverBuffer);
            // received value compared with vase value
			if (packetReceived->getSeqNum() == (base % SEQUENCENUM)){
                // write to ack.log file
				ack_file << packetReceived->getSeqNum() << endl;
				base += 1;
				numReceived += 1;
			}
		}

        // Tests to see if all packets are received
		if (numSent == numReceived){
			// Sending EOT
			nextSequenceNum = base % SEQUENCENUM;
			bzero(sendData, sizeof(sendData));
			packet *packetSent = new packet(3, nextSequenceNum, 0, NULL);
			packetSent->serialize(sendData);
			delete packetSent;
			sendto(sending, sendData, strlen(sendData), 0, (struct sockaddr *) &emulatorSent, size1);
			cout << "Sending EOT packet to server." << endl;
			seqnum_file << nextSequenceNum << endl;

			// Receiving EOT
			bzero(receiverBuffer, sizeof(receiverBuffer));
			recvfrom(receiving, receiverBuffer, sizeof(receiverBuffer), 0, (struct sockaddr *) &emulatorReceived, &size2);
			packetReceived->deserialize(receiverBuffer);
			if (packetReceived->getType() == 2){
				cout << "EOT packet received. Exiting.-----------------------------------" << endl;
				ack_file << packetReceived->getSeqNum() << endl;
				break;
			}

		}

	}

    // Close both sending and receiving ports
  close(sending);
	close(receiving);
    // Close the 2 files generated by client
	seqnum_file.close();
	ack_file.close();
	delete packetReceived;
  return 0;
}
